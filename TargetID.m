% Class to manage mapping vector hits to single targets

classdef TargetID < handle
  properties
    seqdata;  % Data on each naseq
    v256expts;	% V256 groups
    singles;	% Single target
  end
  
  properties(Transient)
    summary;   % TRPSummary
  end
  
  methods
    function tid=TargetID(summary)
      summary.setcontains();
      tid.summary=summary;
      tid.mkvgroups();
      tid.mksingles();
    end
    
    function mkvgroups(tid)
    % Find the groups of non-overlapping V256 groups
      vgroups={};
      vcontains={};
      for i=1:length(tid.summary.cleavage)
        c=tid.summary.cleavage(i);
        if length(c.contains)==256
          % Only V256 expts
          grp=length(vgroups)+1;
          for j=1:length(vgroups)
            if ~any(intersect(c.contains,vcontains{j}))
              % Distinct
              grp=j;
              break;
            end
          end
          if grp>length(vgroups)
            vgroups{grp}=i;
            vcontains{grp}=c.contains;
          else
            vgroups{grp}(end+1)=i;
            vcontains{grp}=union(vcontains{grp},c.contains);
          end
        end
      end
      fprintf('Found %d groups containing [%s] compounds\n', length(vgroups),sprintf('%d ',cellfun(@(z) length(z),vcontains)));
      tid.v256expts=vgroups;
    end
    
    function mksingles(tid)
      tid.singles=[];
      for i=1:length(tid.summary.cleavage)
        c=tid.summary.cleavage(i);
        if length(c.contains)==1
          tid.singles(end+1)=i;
        end
      end
    end
    
    function assign(tid,naseq,varargin)
    % Use the tid.summary generated by summary to figure out which individual targets are likely hits
      defaults=struct('debug',[],'ndrop',1,'minfold',1.5,'alpha',.05,'minvecs',5);
      % ndrop - number of lowest vectors to drop from each set
      %    - if we were sure all vectors would show all hits, this could be 0
      % minvecs - minimum number of vectors needed
      % minfold - only keep compounds that might have a fold>=minfold (that is, we can't reject the hypothesis that fold>=minfold, which given alpha)
      % alpha - alpha for above test
      % debug - list of targets to emit debug messages
      args=processargs(defaults,varargin);

      select=[];   % Targets to select

      n=find(tid.summary.naseq==naseq);
      if isempty(n)
        error('Naseq %d not found in summary', naseq);
      end
      
      fprintf('%2d: %d:',n,tid.summary.naseq(n));
      compounds=Mixtures.instance().find('V5120').contents;   % Compounds (pk) of interest
      vecci=nan(length(compounds),length(tid.summary.cleavage),2);
      vec=nan(length(compounds),length(tid.summary.cleavage));
      vecsamps=nan(length(compounds),length(tid.summary.cleavage),size(tid.summary.cleavage(1).foldsamps,2));
      singleci=nan(length(compounds),2);
      singles=nan(length(compounds),1);
      for i=1:length(tid.summary.cleavage)
        clv=tid.summary.cleavage(i);
        c=clv.contains;
        if ~ismember(c,compounds)
          fprintf('Skipping %s - does not contain any of the 5120 compounds\n', clv.target);
          continue;
        end
        sel=ismember(compounds,c);
        if length(c)==256
          vec(sel,i)=clv.fold(n);
          vecci(sel,i,1)=clv.foldci(n,1);
          vecci(sel,i,2)=clv.foldci(n,2);
          vecsamps(sel,i,:)=repmat(clv.foldsamps(n,:),sum(sel),1);
        elseif length(c)==1 && isfinite(clv.fold(n))
          if isnan(singles(sel)) || singles(sel)<clv.fold(n)
            singles(sel)=clv.fold(n);
            singleci(sel,:)=clv.foldci(n,:);
          end
        end
      end
      
      % Summarize single hits/misses
      singlehits=singleci(:,1)>1;
      singlemisses=singleci(:,2)<1;
      fprintf(' %2d,%2d single hits/misses,',sum(singlehits),sum(singlemisses));
      origvecci=vecci;
      if sum(isfinite(vec(:)))==0
        fprintf('no vector data\n');
        return;
      end
      thresh=[1.2,2.0,3.0,4.0,5.0];  % These are the fold thresholds for calculating estimated # of hits
      s={};esthits=[];
      for k=1:length(thresh)
        clearhigh=vecci(:,:,1)>thresh(k);
        nhigh=sum(any(clearhigh))*((100-tid.summary.cirange(1))/100);
        clearlow=vecci(:,:,2)<thresh(k);
        nlow=sum(any(clearlow))*(tid.summary.cirange(2)/100);
        s{k}=sprintf('%3.0f/%3.0f', nhigh, nlow);
        if nhigh==0
          esthits(k)=0;
        elseif nlow==0
          esthits(k)=999;
        else
          for ek=0:length(compounds)
            % What fraction of vectors would be high if we had this number hits
            expectfrac=1-(1-ek/5120)^256;
            if expectfrac>=(nhigh+1)/(nhigh+nlow+2)
              break;
            end
          end
          esthits(k)=ek;
        end
      end
      fprintf('v#=[%s] ',strjoin(s,','));
      fprintf(' esthits=[%s] ', sprintf('%3d ',esthits));

      % Find any vector hits that contain a target that has at least as high a fold change
      % Mark that vector/target combination as covered by the highest target
      % ord is singles in descending order
      covered=nan(size(vec));
      [stmp,ord]=sort(singles,'asc');
      ord=ord(isfinite(stmp));
      for i=1:length(ord)
        t=ord(i);
        vecsel=find(isfinite(vec(t,:)));
        for j=1:length(vecsel)
          covered(vec(:,vecsel(j))<singles(t),vecsel(j))=t;
        end
        covered(t,vecsel)=nan;   % Don't cover itself
      end
      
      % Any vectors that contain a covered hit are immaterial - blank them
      other=vec;
      other(isfinite(covered))=nan;
      otherci=vecci;
      otherci(isfinite(cat(3,covered,covered)))=nan;
      
      % Calculate vector stats over vectors that are not explained by definite hits
      foldboot=nan(size(vecsamps,1),size(vecsamps,3));
      eflagged=false;
      for i=1:size(vecsamps,1)
        % The vectors in use for this compound
        sel=find(isfinite(vecsamps(i,:,1)));
        if length(sel)<args.minvecs
          if ~eflagged
            fprintf('Not enough vector data for %d for compound %d and possibly others (have %d vecs)\n', naseq, compounds(i),length(sel));
            eflagged=true;
          end
          continue;
        end
        [~,ord]=sort(vecsamps(i,sel,:),2);
        pick=squeeze(ord(1,args.ndrop+1,:));
        for j=1:max(pick)
          foldboot(i,pick==j)=vecsamps(i,sel(j),pick==j);
        end
      end
      meanfold=mean(foldboot,2);
      minfold=prctile(foldboot,5,2);
      maxfold=prctile(foldboot,95,2);

      % Interesting compounds:
      interesting=find(singlehits);   % Have any single compound data
      interesting2=find(mean(foldboot>args.minfold,2)>args.alpha);   % Ones that might be switching
      interesting=union(interesting,interesting2);
      [~,ord]=sort(meanfold(interesting),'desc');
      interesting=interesting(ord);
      for k=1:length(interesting)
        if meanfold(interesting(k))<max(1,meanfold(interesting(min(end,20)))) ...
              && ~(singleci(interesting(k),1)>1)
          continue;
        end


        veccik=squeeze(vecci(interesting(k),:,:));
        vecsel=isfinite(veccik(:,1));
        veccik=veccik(vecsel,:);
        veck=squeeze(vec(interesting(k),:));
        veck=veck(vecsel);
        vecs=squeeze(vecsamps(interesting(k),vecsel,:));
        
        c=compounds(interesting(k));
        recs=Compounds.instance().get(c);
        n={recs.name};
        select=[select,struct('compound',c,'name',n,'minfold',minfold(interesting(k)), 'meanfold',meanfold(interesting(k)),'maxfold', maxfold(interesting(k)), 'vec',veck,'vecci',veccik,'vecs',vecs,'foldboot',squeeze(foldboot(interesting(k),:)),'vecnames',{{tid.summary.cleavage(vecsel).target}},'single',singles(interesting(k)),'singleci',singleci(interesting(k),:),'covered',covered(interesting(k),vecsel))];
      end
      fprintf('\n');
      if isstruct(tid.seqdata)
        tid.seqdata=tid.seqdata([tid.seqdata.naseq]~=naseq);
      end
      tid.seqdata=[tid.seqdata,struct('naseq',naseq,'args',args,'thresh',thresh,'esthits',esthits,'hits',select)];
    end % assign
    
    function res=isolatedrop(tid, naseq, varargin)
    % Isolate a single potential target using the vectors, dropping out 1 vector group at a time
      defaults=struct('ignorecompounds',[],'plot',true,'pctthresh',[],'ignoreknown',true,'verbose',true);
      args=processargs(defaults,varargin);

      allres=[];
      for i=1:length(tid.v256expts)
        %fprintf('Ignoring vector group %d\n',i);
        allres=[allres,tid.isolateone(naseq,'ignorevgroups',i,'ignorecompounds',args.ignorecompounds,'plot',false,'pctthresh',args.pctthresh,'ignoreknown',args.ignoreknown,'verbose',false)];
      end
      if isempty(allres)
        res=[];
        return;
      end
      [~,dropped]=max([allres.thresh]);
      res=allres(dropped);
      res.dropped=dropped;
      res.allres=allres;
      if args.verbose
        fprintf('Best candidate for %d was %.2f-fold, %.2f-gain, %.0f-pctile with vector group %d dropped\n',naseq,res.thresh,res.thresh/res.medianfold,res.threshpct,dropped);
      end
      if args.plot
        % Redo the best one with plotting
        tid.isolateone(naseq,'ignorevgroups',dropped,'ignorecompounds',args.ignorecompounds,'plot',true,'pctthresh',args.pctthresh,'ignoreknown',args.ignoreknown,'verbose',args.verbose);
      end
    end

    function res=isolateone(tid, naseq, varargin)
    % Isolate a single potential target using the vectors
      defaults=struct('ignorevgroups',[],'ignorecompounds',[],'ignoreknown',true,'plot',true,'pctthresh',[],'verbose',true);
      args=processargs(defaults,varargin);

      seqind=find(tid.summary.naseq==naseq);
      if length(seqind)~=1
        error('Naseq %d not in summary\n', naseq);
      end

      if args.ignoreknown
        % Add any single compounds that cause switching for this naseq
        sexpts=tid.summary.cleavage(tid.singles);
        scompounds=[];sfold=[];
        for i=1:length(sexpts)
          c=sexpts(i);
          if isfinite(c.fold(seqind))
            scompounds(end+1)=c.contains;
            sfold(end+1)=c.fold(seqind);
          end
        end
      else
        scompounds=[];
      end
      wouldbechosen=nan(size(scompounds));
      
      %expts=setdiff(horzcat(tid.v256expts{:}),horzcat(tid.v256expts{args.ignorevgroups}),'stable');
      expts=horzcat(tid.v256expts{:});
      ignoreexpts=ismember(horzcat(tid.v256expts{:}),horzcat(tid.v256expts{args.ignorevgroups}))';
      %fprintf('Using %d expts\n', length(expts));
      clv=tid.summary.cleavage(expts);
      swcell=arrayfun(@(z) [z.fold(seqind),z.foldci(seqind,:)],clv,'Unif',false);
      sw=vertcat(swcell{:});
      if ~any(isfinite(sw(:,3)))
        fprintf('Naseq %d has no fold data\n', naseq);
        res=[];
        return;
      end
      all=unique([clv.contains]);
      if isempty(args.pctthresh)
        % Find the highest threshold that gives at least one candidate
        ordsw=sort(sw(:,3),'desc');
        ordsw=ordsw(isfinite(ordsw));

        for i=1:length(ordsw)
          low=unique([clv(sw(:,3)<ordsw(i) & ~ignoreexpts).contains]);
          pos=setdiff(all,[low;args.ignorecompounds(:)]);
          selwbc=find(ismember(scompounds,pos)&isnan(wouldbechosen));
          if ~isempty(selwbc)
            wouldbechosen(selwbc)=ordsw(i);
            for kk=1:length(selwbc)
              k=selwbc(kk);
              if args.verbose
                fprintf('Would have chosen compound %d at threshold %.1f fold,  single measurement had %.1f fold\n',scompounds(k),ordsw(i), sfold(k));
              end
            end
          end
          pos=setdiff(pos,scompounds);
          if length(pos)>0
            thresh=ordsw(i);
            threshpct=mean(sw(:,3)<thresh)*100;
            break;
          end
        end
      else
        % Use the give percentile for the thresh
        threshpct=args.pctthresh;
        thresh=prctile(sw(:,3),args.pctthresh);
        low=unique([clv(sw(:,3)<thresh).contains]);
        pos=setdiff(all,[low;args.ignorecompounds(:);scompounds(:)]);
        if isempty(pos)
          fprintf('No candidates using thresh@%.0f%% = %.2f\n', args.pctthresh, thresh);
          return;
        end
      end
      if ~isempty(args.ignorevgroups)
        igstr=sprintf('ignoring vgroup(s) %s and ',sprintf('%d',args.ignorevgroups));
      else
        igstr='';
      end
      if args.verbose
        fprintf('Found candidates [%s] by %signoring %d compounds, %d measured,  and those with <%.2f fold (%.0f-pctile) for some vector\n',...
                sprintf('%d ',pos), igstr, length(args.ignorecompounds), length(scompounds), thresh, mean(sw(:,3)<thresh)*100);
      end
      
      if args.plot
        ti=sprintf('isolateone %d -> %s',naseq,sprintf('%d ',pos));
        if ~isempty(args.ignorevgroups)
          ti=[ti,sprintf('; ignore vgrp %s',sprintf('%d ',args.ignorevgroups))];
        end
        setfig(ti);clf;
        semilogy(sw);
        hold on;
        haspos=arrayfun(@(z) ~isempty(intersect(pos,z.contains)), clv);
        plot(find(haspos),sw(haspos,3),'or');
        for i=1:length(scompounds)
          if isfinite(wouldbechosen(i))
            hask=arrayfun(@(z) ~isempty(intersect(scompounds(i),z.contains)), clv);
            plot(find(hask),sfold(i),'og');
          end
        end
        hasignore=arrayfun(@(z) ~isempty(intersect(args.ignorecompounds,z.contains)), clv);
        plot(find(hasignore),sw(hasignore,3),'xm');
        % Add vgroup boundaries
        gnum=[];
        ax=axis;
        for i=1:length(expts)
          gnum(i)=find(cellfun(@(z) ismember(expts(i),z),tid.v256expts));
          if i>1 & gnum(i)~=gnum(i-1)
            plot(i-0.5*[1,1],ax(3:4),'r:');
          end
        end
        xlabel('Vector');
        ylabel('Fold');
        title(ti);
      end
      if nargout>0
        res=struct('naseq',naseq,'compound',pos(1),'thresh',thresh,'medianfold',nanmedian(sw(:,3)),'threshpct',threshpct);
      end
    end
    
    function inconsistent(tid)
    % Check for inconsistent patterns
      for n=1:length(tid.seqdata)
        v=tid.seqdata(n);
        for j=1:length(v.hits)
          h=v.hits(j);
          for i=1:size(h.vecci,1)
            inconsistent=h.singleci(1)>2 & h.vecci(i,1)<1 & h.vecci(i,2)<2;
            if inconsistent
              fprintf('Inconsistent %-14.14s=[%3.1f,%3.1f], %-9.9s=[%3.1f,%3.1f] naseq=%d\n',tid.summary.componds.find(h.compound), h.singleci,h.vecnames{i}, h.vecci(i,:),v.naseq);
            end
          end
        end
      end
    end

    function tbl=showswitch(tid,naseq,varargin)
      defaults=struct('minfold',1.5);
      args=processargs(defaults,varargin);

      sel=find([tid.seqdata.naseq]==naseq);
      if isempty(sel)
        fprintf('No target matches for %d\n', naseq);
        return;
      end
      assert(length(sel)==1);
      s=tid.seqdata(sel);
      extra=containers.Map();
      sel=[s.hits.single]>args.minfold | isnan([s.hits.single]);
      hits=s.hits(sel);
      if ~isempty(hits)
        tbl=struct2table(hits,'AsArray',true);
        tbl=removevars(tbl,'covered');
        for i=1:length(hits)
          vstr={};
          h=hits(i);
          for j=1:length(h.vecnames)
            vstr{j}=sprintf('%-5.5s[%3.1f,%3.1f]',strrep(h.vecnames{j},'V256',''),h.vecci(j,:));
            if ~isKey(extra,h.vecnames{j})
              extra(h.vecnames{j})=sprintf('%s(%.1f)',h.name,h.single);
            else
              extra(h.vecnames{j})=sprintf('%s,%s(%.1f)',extra(h.vecnames{j}),h.name,h.single);
            end
          end
          tbl.vstr{i}=strjoin(vstr,',');
          tbl.covered{i}=strrep(strjoin(arrayfun(@(z) sprintf('%4d',z),h.covered,'Unif',false)),'NaN',' . ');
        end
      end

      tid.summary.showswitch(naseq,'minfold',args.minfold,'extra',extra);
      if ~isempty(hits)
        disp(removevars(tbl,{'vec','vecci','vecnames','vecs','foldboot'}));
      end
      
      if nargout<1
        clear tbl;
      end
    end
  
    function targetstomeasure(tid,varargin)
      defaults=struct('minscore',6,'minfold',2,'maxperseq',2,'numhitsperseq',3);
      % debug - list of targets to emit debug messages
      args=processargs(defaults,varargin);

      nseq=0;
      utarget=[];
      for i=1:length(tid.seqdata)
        u=tid.seqdata(i).vechits;
        if isempty(u)
          continue;
        end
        nfound=length(tid.seqdata(i).hits);
        nneed=min(args.maxperseq,args.numhitsperseq-nfound);
        if nneed>0
          sel=[u.score]>=args.minscore & [u.meanfold]>=args.minfold;
          if any(sel)
            nseq=nseq+1;
            t=[u(sel).compound];
            utarget=union(utarget,t(1:min(end,nneed)));
          end
        end
      end
      
      fprintf('Have %d unique untested targets over %d naseq with score>=%d, minfold>=%.2f including up to %d targets/seq\n', length(utarget), nseq, args.minscore, args.minfold,args.maxperseq);

      t=tid.summary.molnames(utarget);
      for i=1:length(t)
        if i>1 && ~strncmp(t{i-1},t{i},8)
          fprintf('\n');
        end
        fprintf('''%s'',',t{i});
      end
      fprintf('\n');
    end % function

    function plothits(obj,ngs,varargin)
    % Plot the hit compounds
    % Note that there is also TRPSummary.plothits() with similar output
    % TargetID version plots hits inferred by either singles or vectors.  
    %   Ones with fold>=thresh are shown
    % TRPSummary version is based only on singles.  It includes compounds if the high 
    %   end of their 90% confidence interval are >thresh
      defaults=struct('ind',1:length(obj.seqdata),'thresh',2,'maxshow',15,'dirname','./plothits','noteothers',false);
      % debug - list of targets to emit debug messages
      args=processargs(defaults,varargin);

      captions={}; ti={}; pk={}; im={};
      % Sort by naseq
      [~,ord]=sort([obj.seqdata(args.ind).naseq]);
      args.ind=args.ind(ord);
      
      for i=args.ind
        s=obj.seqdata(i);
        hits=s.hits;
        if isempty(hits)
          continue;
        end
        fold=[hits.minfold];
        single=[hits.single];
        fold(isfinite(single))=single(isfinite(single));
        [fold,ord]=sort(fold,'desc');
        hits=hits(ord);
        thresh=args.thresh;
        if length(fold)>args.maxshow
          thresh=max(thresh,fold(args.maxshow));
        end
        sel=find(fold>=thresh);
        if ~isempty(sel)
          fprintf('Plotting %d structures with minfold>=%.1f for naseq %d\n', length(sel), thresh, s.naseq);
          notelist={};
          for k=1:length(sel)
            h=hits(sel(k));
            note=sprintf('v>%.1f',h.minfold);
            if isfinite(h.single)
              note=sprintf('%s s=%.1f',note,h.single);
            end
            if args.noteothers
              % Find any other naseqs that are sensitive to this target
              for i2=setdiff(args.ind,i)
                s2=obj.seqdata(i2);
                h2=s2.hits;
                if ~isempty(h2)
                  sel2=[h2.compound]==h.compound;
                  if any(sel2) && h2(sel2).minfold>=thresh
                    note=sprintf('%s x%03d:v>%.1f',note,mod(s2.naseq,1000),h2(sel2).minfold);
                  end
                end
              end
            end
            notelist{end+1}=note;
          end
          captions{end+1}=notelist;
          seq=ngs.seqs.naseqformat(s.naseq);
          ti{end+1}=sprintf('%d %s',s.naseq,seq);
          pk{end+1}=[hits(sel).compound];
          % Plot cleavage
          obj.summary.plotcleavagebyexpt(s.naseq,'expts','single','minfold',args.thresh);
          set(gcf,'Color',[1,1,1]);  % White background
          im{end+1}=imtrim(getframe(gcf).cdata);
          close(gcf);
        else
          fprintf('No hits with minfold>=%.1f for naseq %d\n', thresh, s.naseq);
        end
      end
      Compounds.instance().savehtml(args.dirname,pk,'captions',captions,'title',ti,'images',im,'maintitle',sprintf('Hits with fold >= %.1f (%s)',args.thresh,datestr(now)));
      fprintf('Saved output in %s/index.html\n',args.dirname);
    end

    function res=selectivity(tid,varargin)
    % Compute and plot selectivity vs #ligands
    % Use only single data (max #ligands limited by # measured)
      defaults=struct('minfold',[],'newfig',true);
      args=processargs(defaults,varargin);

      if args.newfig
        setfig('selectivity');clf;
      end
      if isempty(args.minfold)
        args.minfold=[1.5,2,3,4,6,8];
      end
      if length(args.minfold)>1
        leg={};
        res=[];
        for i=1:length(args.minfold)
          res=[res,tid.selectivity('minfold',args.minfold(i),'newfig',false)];
          hold on;
          leg{end+1}=sprintf('%.1f fold',args.minfold(i));
        end
        legend(leg,'Location','SouthEast');
        return;
      end
      hit=[];uc=[];
      for i=1:length(tid.seqdata)
        if ~isempty(tid.seqdata(i).hits)
          s=tid.seqdata(i).hits;
          sel=[s.single]>args.minfold;
          hit([s(sel).compound],i)=true;
          uc=union(uc,[s(isfinite([s.single])).compound]);
        end
      end
      fprintf('Have a total of %d measured compounds\n',length(uc));
      nhit=sum(hit,1);   % Number of hits/aptamer
      ligands=[];
      for i=1:max(nhit)
        ligands(i)=sum(any(hit(:,nhit>0 & nhit<=i),2));
      end
      loglog(1:max(nhit),ligands);
      xlabel('Cross-reactivity (C)');
      ylabel('Number of compounds with cross-reactivity <= C');
      logticks(1,1);
      res=struct('minfold',args.minfold,'crossreactivity',num2cell(1:max(nhit)),'ncompounds',num2cell(ligands));
    end
    
  end % methods
end  % classdef
